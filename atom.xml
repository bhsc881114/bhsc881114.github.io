<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>灰主流创业者</title>
  <icon>https://www.gravatar.com/avatar/faf9a809f81005af1fdebc302e13e150</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bhsc881114.github.io/"/>
  <updated>2018-02-16T06:27:52.000Z</updated>
  <id>http://bhsc881114.github.io/</id>
  
  <author>
    <name>chentao</name>
    <email>bhsc.happy@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis client使用总结</title>
    <link href="http://bhsc881114.github.io/2018/02/15/redis-client%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://bhsc881114.github.io/2018/02/15/redis-client使用总结/</id>
    <published>2018-02-15T12:28:03.000Z</published>
    <updated>2018-02-16T06:27:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了使用redis client的基本配置和连接超限的问题<br><a id="more"></a></p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>连接池实现是基于Apache Commons Pool 2，配置也参考的GenericObjectPoolConfig，分别是minIdle,maxIdle,maxTotal,其中maxTotal包含了活跃和非活跃的连接总数</p><blockquote><p>maximum total connections (maxTotal) includes both active and idle connections.maximum idle connections (maxIdle) are connections that are ready to be used (but are currently unused).</p></blockquote><p>另外timeout是在Jedis的构造函数里指定的，他同时指定了connectionTimeout(最大连接时间)和soTimeout(最大响应时机 )</p><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><p>客户端配置就上面几个，用起来还是挺简单的，但是用的过程中还是会遇到一些问题，比如ERR max number of clients reached，有可能会是以下几个原因</p><h4 id="1-连接数超过限制"><a href="#1-连接数超过限制" class="headerlink" title="1.连接数超过限制"></a>1.连接数超过限制</h4><p>redis server最大连接数的配置由maxclients决定，2.6以后的版本默认值是10000，如果设置的值超过了操作系统的最大值限制，则会在启动的时候给出提示</p><blockquote><p>$ ./redis-server –maxclients 100000<br>[41422] 23 Jan 11:28:33.179 # Unable to set the max number of files limit to 100032 (Invalid argument), setting the max clients configuration to 10112.</p></blockquote><h4 id="2-timeout没有配置"><a href="#2-timeout没有配置" class="headerlink" title="2.timeout没有配置"></a>2.timeout没有配置</h4><p>一般情况下，超过10000的最大连接数，是使用上的问题，首先redis服务端默认的timout配置的是0，即不会关闭连接，即便这个连接已经空闲很久，这时候如果客户端在重启前没有关闭连接或者说中间有防火墙之类的断开了连接，redis 服务端将会永久保留这些连接，这时候只要配置timeout即可</p><blockquote><p>config get timeout ## 查看timeout配置</p></blockquote><h4 id="3-keepalive的设置"><a href="#3-keepalive的设置" class="headerlink" title="3.keepalive的设置"></a>3.keepalive的设置</h4><p>除了timeout也还可以通过keepalive配置来解决，比如sentinel的连接超时时间，timeout的配置是不生效的，这里的keepalive指的是TCP协议层的配置，他有三个参数影响：</p><blockquote><p>tcp_keepalive_time     default 7200 seconds<br>tcp_keepalive_probes   default 9<br>tcp_keepalive_intvl    default 75 seconds</p></blockquote><p>超时公式为：</p><blockquote><p>tcp_keepalive_time+tcp_keepalive_intvl*tcp_keepalive_probes=7895s=131.58min</p></blockquote><p>这个时间还是挺久的，redis服务端在3.2版本已经以后，默认设置了tcp_keepalive_time为300秒(以前的版本默认为0，也就是不启用)</p><p>配置上这个参数之后，对于一些客户端没有正常关闭的场景也能及时的关闭</p><h4 id="4-正确关闭客户端连接"><a href="#4-正确关闭客户端连接" class="headerlink" title="4.正确关闭客户端连接"></a>4.正确关闭客户端连接</h4><p>另外说到客户端的正确配置，如果是使用Spring的话，只要配置下bean的destroy-method，在这里关闭连接池即可，如果没有用Spring，则要自己注册一个ShutdownHook</p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.<a href="http://coolnull.com/2842.html" target="_blank" rel="noopener">redis报-ERR max number of clients reached错误</a><br>2.<a href="http://coryklein.com/tcp/2015/11/25/custom-configuration-of-tcp-socket-keep-alive-timeouts.html" target="_blank" rel="noopener">Custom Configuration of TCP Socket Keep-Alive Timeouts</a><br>3.<a href="https://redis.io/topics/clients" target="_blank" rel="noopener">Redis Clients Handling</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了使用redis client的基本配置和连接超限的问题&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="http://bhsc881114.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="http://bhsc881114.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>nginx运维小纪</title>
    <link href="http://bhsc881114.github.io/2015/07/18/nginx%E8%BF%90%E7%BB%B4%E5%B0%8F%E7%BA%AA/"/>
    <id>http://bhsc881114.github.io/2015/07/18/nginx运维小纪/</id>
    <published>2015-07-18T08:50:10.000Z</published>
    <updated>2015-07-19T14:25:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近搭了nginx作为日志服务器来做性能和操作分析，记录一下过程和遇到的一些问题<br><a id="more"></a></p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="按天滚动"><a href="#按天滚动" class="headerlink" title="按天滚动"></a>按天滚动</h2><p>按天滚动一开始配置了logrotate实现，执行时间配置为0点0分，但实际真正执行时间是0点1分，一开始怀疑是其他cron.daily的其他任务影响，毕竟cron.daily会处理很多东西<br><img src="http://7xijc0.com1.z0.glb.clouddn.com/nginx1.png" alt="cron.daily"></p><p>在cron.daily其他脚本上加了个日志，统计开始时间和结束时间，确实发现logrotate因为freshclam的影响延迟了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start freshclam 00:01:04</span><br><span class="line">end freshclam 00:01:16</span><br><span class="line">start logrotate 00:01:17</span><br></pre></td></tr></table></figure></p><p>但是还是不能解释为什么不是0分开始，最后老老实实配置了一个独立的任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * * * ~/tengine/logrotate.sh</span><br></pre></td></tr></table></figure></p><h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><p>默认格式的分隔符比较混乱，因此采用了0x01，就是用vim编辑的时候要注意不是0x01，而是ctrl+v,ctrl+a </p><h2 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h2><p>日志里面和时间相关的变量主要是2个，$request_time和$upstream_response_time</p><blockquote><p>$request_time就是从接请求的第一个字节到发送完响应数据的时间，即包括接收请求数据时间、程序响应时间、输出响应数据时间。<br>$upstream_response_time指从Nginx向后端建立连接开始到接受完数据然后关闭连接为止的时间。</p></blockquote><p>$request_time肯定比$upstream_response_time值大，特别是使用POST方式传递参数时，因为Nginx会把request body缓存住，接受完毕后才会把数据一起发给后端。所以如果用户网络较差，或者传递数据较大时，$request_time会比$upstream_response_time大很多</p><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><p>我们的模式是将日志定时同步到hadoop集群再进行分析，不过也发现goaccess这个工具，可以比较好的分析日志，唯一的缺点是日志比较大的时间cpu飙高。。所以要分析最好换一台机器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goaccess -f tengine/logs/a.log -a --date-format=%F --time-format=%T --log-format=&quot;%h %d %t %U %s %b %R %u %^ %^ %L&quot;</span><br></pre></td></tr></table></figure></p><h2 id="referer-CFNetwork"><a href="#referer-CFNetwork" class="headerlink" title="referer CFNetwork"></a>referer CFNetwork</h2><p>发现很多ua是 CFNetwork/672.X.X Darwin/14.X.X的没有referer，怀疑是某些网络环境下客户端不是webview而是用的CFNetwork库l来请求</p><hr><h1 id="性能配置"><a href="#性能配置" class="headerlink" title="性能配置"></a>性能配置</h1><h2 id="进程数和连接数配置"><a href="#进程数和连接数配置" class="headerlink" title="进程数和连接数配置"></a>进程数和连接数配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  3;</span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    multi_accept on;</span><br><span class="line">    worker_connections  4024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="长连接和超时"><a href="#长连接和超时" class="headerlink" title="长连接和超时"></a>长连接和超时</h2><p>我们的服务简单，量还比较大，所以就把这个时间配置的尽量小，实际操作中发现基本维持在400来个连接，连接数基本是请求量的1/2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keepalive_timeout  12;</span><br></pre></td></tr></table></figure></p><blockquote><p>curl ‘<a href="http://127.0.0.1/nginx-status" target="_blank" rel="noopener">http://127.0.0.1/nginx-status</a>‘<br>Active connections: 418<br>server accepts  handled  requests request_time<br>        14168862 14168862 25943492 226096881<br>Reading: 1 Writing: 1 Waiting: 416 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 下面的两个timeout一开始配置成10s，发现有部分http状态码是408的日志，就是因为10s超时，1分钟还是会有几条这样的错误，最重要的是错误了以后这个日志会打到根的access.log，后面把这个值调大到30</span><br><span class="line">client_header_timeout  30;</span><br><span class="line">client_body_timeout    30;</span><br></pre></td></tr></table></figure><h2 id="sendfile、nopush、nodelay"><a href="#sendfile、nopush、nodelay" class="headerlink" title="sendfile、nopush、nodelay"></a>sendfile、nopush、nodelay</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sendfile        on;</span><br><span class="line">tcp_nopush     on;</span><br><span class="line">tcp_nodelay    on;</span><br></pre></td></tr></table></figure><p>TCP 传输的MSS有1460字节，为了提升网络利用率，避免拥塞，Nagle算法在发现要发送的数据太小的时候，会延时超过200ms再发送或者等数据超过MSS再发送，通过tcp_nodelay on可以关闭这个算法。当然这个选项是在长连接的情况下才有效的</p><p>tcp_nopush实际上对应的是linux tcp栈的TCP_CORK选项，他会禁止小包的发送，直到超过MSS。在nginx他，他在sendfile on的情况下才有效。sendfile可以让静态数据在内核态直接发送数据，而不用上下文切换进入用户态再发送。</p><p>tcp_nodelay和tcp_nopush结合的时候，首先tcp_nopush会堆积数据直到MSS才发送，之后移除tcp_nopush，剩下的最后1个包会因为tcp_nodelay马上发送。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>gzip压缩、文件缓存等，不过在我们场景下并没有启用</p><h2 id="tcp协议栈"><a href="#tcp协议栈" class="headerlink" title="tcp协议栈"></a>tcp协议栈</h2><p>协议栈主要是调整下滑动窗口大小，端口范围，backlog等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># accept的队列长度</span><br><span class="line">net.core.somaxconn = 3240000</span><br><span class="line"># 所有进程打开的文件总数</span><br><span class="line"># 设置echo  6553560 &gt; /proc/sys/fs/file-max</span><br><span class="line"># 或修改 /etc/sysctl.conf, 加入</span><br><span class="line"># fs.file-max = 6553560 重启生效</span><br><span class="line">sys.fs.file_max</span><br><span class="line">#向外连接的端口范围</span><br><span class="line">net.ipv4.ip_local_port_range = 2000 65000 </span><br><span class="line"># 支持更大的TCP窗口. 如果TCP窗口最大超过65535(64KB), 必须设置该数值为1</span><br><span class="line">net.ipv4.tcp_window_scaling = 1</span><br><span class="line"># 同时所处理的最大timewait数量</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 6000</span><br><span class="line"># 接收缓冲区默认值</span><br><span class="line">net.core.rmem_default = 8388608</span><br><span class="line"># 发送缓冲区默认值</span><br><span class="line">net.core.wmem_default = 8388608</span><br><span class="line"># 接收缓冲区最大值</span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line"># 发送缓冲区最大值</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line"># TCP接收缓冲区，min default max</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 16777216</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 16777216</span><br></pre></td></tr></table></figure></p><h2 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h2><p>ulimit 设置当前shell以及由它启动的进程的资源限制，修改/etc/security/limits.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65535 </span><br><span class="line">* hard nofile 65535</span><br></pre></td></tr></table></figure></p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.<a href="http://huoding.com/2013/04/21/246" target="_blank" rel="noopener">被遗忘的Logrotate</a><br>2.<a href="http://blog.linezing.com/?p=950" target="_blank" rel="noopener">使用nginx记日志</a><br>3.<a href="https://www.nginx.com/blog/tuning-nginx/" target="_blank" rel="noopener">Tuning NGINX for Performance</a><br>4.<a href="http://jerrypeng.me/2013/08/mythical-40ms-delay-and-tcp-nodelay/" target="_blank" rel="noopener">神秘的40毫秒延迟与 TCP_NODELAY</a><br>5.<a href="http://imququ.com/post/my-nginx-conf-for-wpo.html" target="_blank" rel="noopener">Nginx 配置之性能篇</a><br>6.<a href="https://t37.net/nginx-optimization-understanding-sendfile-tcp_nodelay-and-tcp_nopush.html" target="_blank" rel="noopener">UNDERSTANDING SENDFILE, TCP_NODELAY AND TCP_NOPUSH</a><br>7.<a href="http://blog.jobbole.com/87531/" target="_blank" rel="noopener">为最佳性能调优 Nginx</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近搭了nginx作为日志服务器来做性能和操作分析，记录一下过程和遇到的一些问题&lt;br&gt;
    
    </summary>
    
      <category term="服务端运维" scheme="http://bhsc881114.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="nginx" scheme="http://bhsc881114.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>HTTP请求的TCP瓶颈分析</title>
    <link href="http://bhsc881114.github.io/2015/06/23/HTTP%E8%AF%B7%E6%B1%82%E7%9A%84TCP%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90/"/>
    <id>http://bhsc881114.github.io/2015/06/23/HTTP请求的TCP瓶颈分析/</id>
    <published>2015-06-23T11:38:43.000Z</published>
    <updated>2015-07-11T23:04:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xijc0.com1.z0.glb.clouddn.com/TCP-Stack.png" alt="tcp-stack"></p><p>针对<strong>三次握手、流量控制（接收窗口）、慢启动（cwnd，拥塞窗口）、队首阻塞</strong>等方面看下TCP对HTTP的影响</p><a id="more"></a><hr><p>这篇文章基本是对《Web性能权威指南》第一章和第二章的读书笔记，另外加一些扩展内容,这本书确实赞，推荐</p><h1 id="高带宽和低延迟"><a href="#高带宽和低延迟" class="headerlink" title="高带宽和低延迟"></a>高带宽和低延迟</h1><p>所有网络通信都有决定性影响的两个方面:<strong>延迟和带宽</strong></p><ul><li>延迟 分组从信息源发送到目的地所需的时间。</li><li>带宽 逻辑或物理通信路径最大的吞吐量</li></ul><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/HTTP-TCP1.png" alt="viewport-index"></center><h2 id="延迟的因素"><a href="#延迟的因素" class="headerlink" title="延迟的因素"></a>延迟的因素</h2><ul><li><strong>传播延迟</strong> 消息从发送端到接收端需要的时间（不超过光速）</li><li><strong>传输延迟（带宽/窗口）</strong> 把消息中的所有比特转移到链路中需要的时间,是消息长度和链路速率的函数（10M/s和1M/s的线路，时间不一样）</li><li><strong>处理延迟</strong> 处理分组首部、检查位错误及确定分组目标所需的时间（路由器分包）</li><li><strong>排队延迟</strong> 到来的分组排队等待处理的时间</li></ul><h2 id="速度延时"><a href="#速度延时" class="headerlink" title="速度延时"></a>速度延时</h2><p>假定光通过光纤的速度 约为每秒 200 000 000 米,对应的折射率约为 1.5，从纽约到悉尼的一个往返(RTT)也要花 160 ms，分组旅行的距离比这要长得多。这条线路中的 每一跳都会涉及寻路、处理、排队和传输延迟。结果呢,纽约到悉尼的实际 RTT, 大约在 200~300 ms 之间。</p><blockquote><p>中美骨干网单向数据延时≈60ms，所以中国用户访问美国主机数据传输的延时理论值高于120ms（RTT）</p></blockquote><h2 id="带宽延时"><a href="#带宽延时" class="headerlink" title="带宽延时"></a>带宽延时</h2><p>核心数据路径的骨干或光纤连接,每秒能够处理数百太比特信息，比如中美之间的海底光纤。光纤就是一根“光导管”,传送光信号。金属线则用于传送电信号,但信号损失、电磁干扰较大,同时维护成本也较高。</p><p>通过<strong>波分复用(WDM,Wavelength-Division Multiplexing)</strong>技术,光纤可以同时传输很多不同波长(信道)的光，2010年初,研究人员已经可以在每个信道中耦合400多种波长的光线,最大容量可达171Gbit/s,而一条光纤的总带宽能够达到70Tbit/s </p><h2 id="最后一公里延时-tracerouter"><a href="#最后一公里延时-tracerouter" class="headerlink" title="最后一公里延时-tracerouter"></a>最后一公里延时-tracerouter</h2><p>骨干线路可以有TB的带宽，但是网络边缘的容量就小得多了,而且很大程度上取决于部署技术,比如拔号连接、 DSL、电缆、各种无线技术、光纤到户。<strong><a href="http://www.akamai.io" target="_blank" rel="noopener">akamai</a>每季度都会发布全球的带宽报告</strong></p><p>通过tracerouter工具，可以查看路由拓扑，最后一公里的延迟与提供商、部署方法、网络拓扑,甚至一天中的哪个时段都有很 大关系。作为最终用户,如果你想提高自己上网的速度,那选择延迟最短的ISP是最关键的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Traceroute sends out three packets per TTL increment. Each column corresponds to the </span><br><span class="line">time is took to get one packet back (round-trip-time).</span><br><span class="line"></span><br><span class="line">traceroute to xx.com (121.41.167.43), 30 hops max, 60 byte packets</span><br><span class="line"> 1  198.11.175.248 (198.11.175.248)  0.879 ms  0.898 ms  0.950 ms</span><br><span class="line"> 2  10.107.64.14 (10.107.64.14)  0.945 ms 10.107.64.22 (10.107.64.22)  1.033 ms 10.107.64.18 (10.107.64.18)  75.379 ms</span><br><span class="line"> 3  198.11.128.162 (198.11.128.162)  135.636 ms 198.11.128.154 (198.11.128.154)  0.913 ms 198.11.128.178 (198.11.128.178)  5.472 ms</span><br><span class="line"> 4  218.30.53.93 (218.30.53.93)  4.542 ms 218.30.53.97 (218.30.53.97)  2.144 ms 218.30.53.126 (218.30.53.126)  2.334 ms</span><br><span class="line"> 5  202.97.51.253 (202.97.51.253)  160.089 ms  160.170 ms  160.077 ms</span><br><span class="line"> 6  202.97.35.105 (202.97.35.105)  188.541 ms  190.518 ms  188.903 ms</span><br><span class="line"> 7  202.97.33.37 (202.97.33.37)  168.075 ms  168.109 ms  168.016 ms</span><br><span class="line"> 8  202.97.55.14 (202.97.55.14)  192.583 ms  192.572 ms  192.591 ms</span><br><span class="line"> 9  220.191.135.106 (220.191.135.106)  201.476 ms  201.542 ms  201.465 ms</span><br><span class="line">10  115.236.101.209 (115.236.101.209)  211.315 ms  211.305 ms *</span><br><span class="line">11  42.120.244.194 (42.120.244.194)  270.211 ms 42.120.244.178 (42.120.244.178)  163.768 ms  163.700 ms</span><br><span class="line">12  42.120.244.238 (42.120.244.238)  191.543 ms 42.120.244.246 (42.120.244.246)  248.825 ms  248.910 ms</span><br></pre></td></tr></table></figure><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p><strong>高带宽</strong><br>目前还没有理由认为带宽会停止增长的脚步，就算技术停滞不前,还是可以铺设更多的光缆</p><p><strong>低延时</strong></p><blockquote><p>减少延迟相比带宽困难的多，从很多方面来看,我们的基础设施似乎也已经达到了这个极限。这就显得理解和调优网络协议显得特别重要</p></blockquote><hr><h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/http-tcp2.png" alt="viewport-index"></center><p>客户端可以在发送 ACK分组之后立即发送数据,而服务器必须等接收到ACK分组之后才能发送数据。这个启动通信的过程适用于所有 TCP 连接,因此对所有使用TCP的应用具有非常大的性能影响,<strong>每次传输应用数据之前,都必须经历一次完整的往返</strong></p><blockquote><p>中美之间一次RTT最低120，假设你发起一个简单的HTTP请求，需要一次握手+一次数据传输 = 240ms，浪费了50%的时间，这也意味着提高TCP应用性能的关键在于想办法重用连接</p></blockquote><p>扩展：TFO(TCP Fast Open,TCP 快速打 开)机制,致力于减少新建 TCP 连接带来的性能损失</p><h1 id="流量控制（窗口rwnd）"><a href="#流量控制（窗口rwnd）" class="headerlink" title="流量控制（窗口rwnd）"></a>流量控制（窗口rwnd）</h1><p>rwnd是端到端的控制机制，预防发送过多的数据,TCP连接的每一方都会通告自己的接收窗口,其中包含能够保存数据的缓冲区空间大小信息。TCP 连接的整个生命周期:每个 ACK 分组都会携带相应的最新rwnd 值,以便两端动态调整数据流速,使之适应发送端和接收端的容量及处理能力</p><p>窗口的值原来只有16位，即65535，所以以前rwnd的最大值不能超过64K。现在基本都有了“TCP 窗口缩放”(TCP Window Scaling)，把接收窗口大小由 65 535 字节提高到 1G 字节，在 Linux 中,可以通过如下命 令检查和启用窗口缩放选项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; sysctl net.ipv4.tcp_window_scaling</span><br><span class="line">$&gt; sysctl -w net.ipv4.tcp_window_scaling=1</span><br></pre></td></tr></table></figure></p><h2 id="rwnd的设置"><a href="#rwnd的设置" class="headerlink" title="rwnd的设置"></a>rwnd的设置</h2><p>如果我们出于传输性能的考虑，当然这个值设置的越大越好,Linux中通过配置内核参数里接收缓冲的大小，进而可以控制接收窗口的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; sysctl -a | grep mem</span><br><span class="line">net.ipv4.tcp_rmem = &lt;MIN&gt; &lt;DEFAULT&gt; &lt;MAX&gt;</span><br></pre></td></tr></table></figure></p><p>还有个问题,当大量请求同时到达时，内存会不会爆掉？通常不会，因为Linux本身有一个缓冲大小自动调优的机制，窗口的实际大小会自动在最小值和最大值之间浮动，以期找到性能和资源的平衡点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过如下方式可以确认缓冲大小自动调优机制的状态（0：关闭、1：开启）：</span><br><span class="line">shell&gt; sysctl -a | grep tcp_moderate_rcvbuf</span><br></pre></td></tr></table></figure><h1 id="慢启动（cwnd，拥塞窗口）"><a href="#慢启动（cwnd，拥塞窗口）" class="headerlink" title="慢启动（cwnd，拥塞窗口）"></a>慢启动（cwnd，拥塞窗口）</h1><p>两端流量控制确实可以防止发送端向接收端过多发送数据,但却没有机制预防任何一端向潜在网络过多发送数据。换句话说,发送端和接收端在连接建立之初,谁也不知道可用带宽是多少,因此需要一个估算机制,<strong>然后根据网络中不断变化的条件 而动态改变速度:TCP能传输的最大数据 = MIN（rwnd,cwnd）</strong></p><p>慢启动的算法如下(cwnd全称Congestion Window)：</p><ul><li>1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。</li><li>2）每当收到一个ACK，cwnd++; 呈线性上升</li><li>3）每当过了一个RTT，cwnd = cwnd*2; 呈指数让升</li><li>4）还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</li></ul><blockquote><p>最初,cwnd 的值只有1个TCP segment。99 年 4 月,RFC 2581 将其增加到了 4 个 TCP segment。2013 年 4 月,RFC 6928 再次将其提高到 10 个 TCP segment</p></blockquote><h2 id="慢启动过程"><a href="#慢启动过程" class="headerlink" title="慢启动过程"></a>慢启动过程</h2><p>服务器向客户端发送 4 个 TCP segment,然后就必须停下来等待确认。此后,每收到一个 ACK, 慢启动算法就会告诉服务器可以将它的 cwnd 窗口增加 1 个 TCP segment.这个阶段通常被称为<strong>指数增长</strong>阶段,因为客户端和服务器都在向两者之间网络路径的有效带宽迅速靠拢</p><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/http-tcp4.png" alt="viewport-index"></center><p>计算达到指定窗口所需要的时间公式：</p><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/HTTP-TCP5.PNG" alt="viewport-index"></center><ul><li>客户端和服务器的接收窗口为 65 535 字节(64 KB);</li><li>初始的拥塞窗口:4 个segment(一个segment 一般是1460B);</li><li>往返时间是 56 ms(伦敦到纽约)。</li></ul><p>为了达到64KB限制，我们将需要把拥塞窗口增加到45个segment，这将花费224毫秒。</p><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/HTTP-TCP6.PNG" alt="viewport-index"></center><h2 id="慢启动的影响"><a href="#慢启动的影响" class="headerlink" title="慢启动的影响"></a>慢启动的影响</h2><p>无论带宽多大,每个 TCP 连接都必须经过慢 启动阶段。换句话说,我们不可能一上来就完全利用连接的最大带宽。</p><p>慢启动导致客户端与服务器之间经过几百 ms 才能达到接近最大速度的问题,对于大型流式下载服务的影响不显著,因为慢启动的时间可以分摊到整个传输周期内消化掉。</p><blockquote><p>对于很多 HTTP 连接,特别是一些短暂、突发的连接而言,常常会出现还没 有达到最大窗口请求就被终止的情况。换句话说,很多 Web 应用的性能经常受到服 务器与客户端之间往返时间的制约。因为慢启动限制了可用的吞吐量,而这对于小 文件传输非常不利。</p></blockquote><h2 id="慢启动对HTTP影响的一次计算"><a href="#慢启动对HTTP影响的一次计算" class="headerlink" title="慢启动对HTTP影响的一次计算"></a>慢启动对HTTP影响的一次计算</h2><p>假设通过HTTP传输一个20K的文件，初始条件：</p><ul><li>往返时间:56 ms。</li><li>客户端到服务器的带宽:5 Mbit/s。</li><li>客户端和服务器接收窗口:65 535 字节。</li><li>初始的拥塞窗口:4 segment(4×1460 字节 ≈ 5.7 KB)。</li><li>服务器生成响应的处理时间:40 ms。</li><li>没有分组丢失、每个分组都要确认、GET 请求只占 1 段。</li></ul><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/HTTP-TCP7.PNG" alt="viewport-index"></center><ul><li>0 ms:客户端发送 SYN 分组开始 TCP 握手。</li><li>28 ms:服务器响应 SYN-ACK 并指定其 rwnd 大小。</li><li>56 ms:客户端确认 SYN-ACK,指定其 rwnd 大小,并立即发送 HTTP GET 请求。<br>8 84 ms:服务器收到 HTTP 请求。</li><li>124 ms:服务器生成 20 KB 的响应,并发送 4 个 TCP 段(初始 cwnd 大小为 4),<br>然后等待 ACK。</li><li>152 ms:客户端收到 4 个段,并分别发送 ACK 确认。</li><li>180 ms:服务器针对每个 ACK 递增 cwnd,然后发送 8 个 TCP 段。</li><li>208 ms:客户端接收 8 个段,并分别发送 ACK 确认。</li><li>236 ms:服务器针对每个 ACK 递增 cwnd,然后发送剩余的 TCP 段。</li><li>264 ms:客户端收到剩余的 TCP 段,并分别发送 ACK 确认。</li></ul><p>作为对比，重用连接，再发一次请求</p><ul><li>0 ms:客户端发送 HTTP 请求。</li><li>28 ms:服务器收到 HTTP 请求。</li><li>68 ms:服务器生成 20 KB 响应,但 cwnd 已经大于发送文件所需的 15 段了,因<br>此一次性发送所有数据段。</li><li>96 ms:客户端收到所有 15 个段,分别发送 ACK 确认。</li></ul><p><strong>同一个连接、同样的请求,但没有三次握手和慢启动,只花了 96 ms,性能提升幅 度达 275% !</strong></p><h2 id="拥塞窗口的合适值"><a href="#拥塞窗口的合适值" class="headerlink" title="拥塞窗口的合适值"></a>拥塞窗口的合适值</h2><p>Google在这方面做了大量的研究，权衡了效率和稳定性之后，最终给出的建议是10MSS。如果你的Linux版本不太旧的话，那么可以通过如下方法来调整「cwnd」初始值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; ip route | while read p; do</span><br><span class="line">           ip route change $p initcwnd 10;</span><br><span class="line">       done</span><br></pre></td></tr></table></figure></p><p>需要提醒的是片面的提升发送端「cwnd」的大小并不一定有效，这是因为前面我们说过网络中实际传输的未经确认的数据大小取决于「rwnd」和「cwnd」中的小值，所以一旦接收方的「rwnd」比较小的话，会阻碍「cwnd」的发挥。</p><h1 id="拥塞预防"><a href="#拥塞预防" class="headerlink" title="拥塞预防"></a>拥塞预防</h1><p>拥塞预防算法把丢包作为网络拥塞的标志,即路径中某个连接或路由器已经拥堵了, 以至于必须采取删包措施。因此,必须调整窗口大小,以避免造成更多的包丢失, 从而保证网络畅通。</p><p>重置拥塞窗口后,拥塞预防机制按照自己的算法来增大窗口以尽量避免丢包。某个 时刻,可能又会有包丢失,于是这个过程再从头开始。<strong>如果你看到过 TCP 连接的吞 吐量跟踪曲线,发现该曲线呈锯齿状,那现在就该明白为什么了</strong>。这是拥塞控制和 预防算法在调整拥塞窗口,进而消除网络中的丢包问题。</p><blockquote><p>最初,TCP 使用 AIMD(Multiplicative Decrease and Additive Increase,倍减加增) 算法,即发生丢包时,先将拥塞窗口减半,然后每次往返再缓慢地给窗口增加一 个固定的值。不过,很多时候 AIMD 算法太过保守,因此又有了很多新的算法，比如DSACK：可以让协议知道是什么原因丢包，是重传还是丢失</p></blockquote><h1 id="带宽延迟积"><a href="#带宽延迟积" class="headerlink" title="带宽延迟积"></a>带宽延迟积</h1><p>发送端和接收端之间在途未确认的最大数据量,取决于拥塞窗 口(cwnd)和接收窗口(rwnd)的最小值。接收窗口会随每次 ACK 一起发送,而 拥塞窗口则由发送端根据拥塞控制和预防算法动态调整.</p><p><strong>BDP(Bandwidth-delay product,带宽延迟积)</strong><br>数据链路的容量与其端到端延迟的乘积。这个结果就是任意时刻处于在途未确认 状态的最大数据量。无论发送端发送的数据还是接收端接收的数据超过了未确认的最大数据量,都必须停 下来等待另一方 ACK 确认某些分组才能继续 </p><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/http-tcp8.png" alt="viewport-index"></center><blockquote><p>那么,流量控制窗口(rwnd)和拥塞控制窗口(cwnd)的值多大合适?实际上,计算过程很简单。首先,假设 cwnd 和 rwnd 的最小值为 16 KB,往返时间为 100 ms: </p></blockquote><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/http-tcp10.png" alt="viewport-index"></center><blockquote><p>不管发送端和接收端的实际带宽多大,这个 TCP 连接的数据传输速率不会超过 1.31 Mbit/s !想提高吞吐量,要么增大最小窗口值,要么减少往返时间。窗口至少需要 122.1 KB 才能充分利用 10 Mbit/s 带宽!如果没有“窗口 缩放(RFC 1323)”,TCP 接收窗口最大只有 64 KB</p></blockquote><h1 id="队首阻塞造成的延时"><a href="#队首阻塞造成的延时" class="headerlink" title="队首阻塞造成的延时"></a>队首阻塞造成的延时</h1><p>每个 TCP 分组都会带着一个唯一的序列号被发出,而 所有分组必须按顺序传送到接收端。如果中途有一个分组没能到达接收 端,那么后续分组必须保存在接收端的 TCP 缓冲区,等待丢失的分组重发并到达接 收端。这一切都发生在 TCP 层,应用程序对 TCP 重发和缓冲区中排队的分组一无所 知,必须等待分组全部到达才能访问数据。在此之前,应用程序只能在通过套接字 读数据时感觉到延迟交付。这种效应称为 <strong>TCP 的队首(HOL,Head of Line)阻塞</strong></p><p>队首阻塞造成的延迟<strong>可以让我们的应用程序不用关心分组重排和重组,从而让代码 保持简洁。然而,代码简洁也要付出代价,那就是分组到达时间会存在无法预知的 延迟变化。这个时间变化通常被称为抖动</strong></p><p><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/http-tcp11.png" alt="viewport-index"></center><br>事实上,某些场景下,丢包是让 TCP 达到最佳性能的关键。有些应用程序可以容忍丢失一 定数量的包,比如语音和游戏状态通信,就不需要可靠传输或按序交付</p><h1 id="针对TCP的优化建议"><a href="#针对TCP的优化建议" class="headerlink" title="针对TCP的优化建议"></a>针对TCP的优化建议</h1><p>每个算法和反馈机制的具体细节可能会继续发展,但核心原理以及 它们的影响是不变的:</p><ul><li>TCP 三次握手增加了整整一次往返时间;</li><li>TCP 慢启动将被应用到每个新连接;</li><li>TCP 流量及拥塞控制会影响所有连接的吞吐量;</li><li>TCP 的吞吐量由当前拥塞窗口大小控制。</li></ul><blockquote><p>结果,现代高速网络中 TCP 连接的数据传输速度,往往会受到接收端和发送端之 间往返时间的限制。另外,尽管带宽不断增长,但延迟依旧受限于光速,而且已经 限定在了其最大值的一个很小的常数因子之内。大多数情况下,TCP 的瓶颈都是延迟,而非带宽</p></blockquote><h2 id="服务器配置调优"><a href="#服务器配置调优" class="headerlink" title="服务器配置调优"></a>服务器配置调优</h2><ul><li><p>增大TCP的初始拥塞窗口<br>加大起始拥塞窗口可以让 TCP 在第一次往返就传输较多数据,而随后的速度提 升也会很明显。对于突发性的短暂连接,这也是特别关键的一个优化。</p></li><li><p>慢启动重启<br>在连接空闲时禁用慢启动可以改善瞬时发送数据的长 TCP 连接的性能。</p></li><li><p>窗口缩放(RFC 1323) 启用窗口缩放可以增大最大接收窗口大小,可以让高延迟的连接达到更好吞 吐量。</p></li><li><p>TCP快速打开<br>在某些条件下,允许在第一个 SYN 分组中发送应用程序数据。TFO(TCP Fast Open,TCP 快速打开)是一种新的优化选项,需要客户端和服务器共同支持。 为此,首先要搞清楚你的应用程序是否可以利用这个特性。</p></li></ul><p>以上几个设置再加上最新的内核,可以确保最佳性能:每个 TCP 连接都会具有较低 的延迟和较高的吞吐量。</p><h2 id="应用程序行为调优"><a href="#应用程序行为调优" class="headerlink" title="应用程序行为调优"></a>应用程序行为调优</h2><ul><li>再快也快不过什么也不用发送,能少发就少发。</li><li>我们不能让数据传输得更快,但可以让它们传输的距离更短。</li><li><strong>重用 TCP 连接是提升性能的关键</strong></li></ul><h2 id="性能检查清单"><a href="#性能检查清单" class="headerlink" title="性能检查清单"></a>性能检查清单</h2><ul><li>把服务器内核升级到最新版本(Linux:3.2+);</li><li>确保 cwnd 大小为 10;</li><li>禁用空闲后的慢启动;</li><li>确保启动窗口缩放;</li><li>减少传输冗余数据;</li><li>压缩要传输的数据;</li><li>把服务器放到离用户近的地方以减少往返时间;</li><li>尽最大可能重用已经建立的 TCP 连接</li></ul><p>#参考</p><ul><li><a href="http://www.zrblog.net/5575.html" target="_blank" rel="noopener">美国机房及中美网络延时状况</a></li><li><a href="http://huoding.com/2013/11/21/299" target="_blank" rel="noopener">浅谈TCP优化（rwnd和cwnd的测量和计算）</a></li><li><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a></li><li><a href="http://blog.buildingautomationmonthly.com/what-is-the-tcpip-stack/" target="_blank" rel="noopener">What is the TCP/IP Stack</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xijc0.com1.z0.glb.clouddn.com/TCP-Stack.png&quot; alt=&quot;tcp-stack&quot;&gt;&lt;/p&gt;
&lt;p&gt;针对&lt;strong&gt;三次握手、流量控制（接收窗口）、慢启动（cwnd，拥塞窗口）、队首阻塞&lt;/strong&gt;等方面看下TCP对HTTP的影响&lt;/p&gt;
    
    </summary>
    
      <category term="HTTP性能" scheme="http://bhsc881114.github.io/categories/HTTP%E6%80%A7%E8%83%BD/"/>
    
      <category term="TCP性能" scheme="http://bhsc881114.github.io/categories/HTTP%E6%80%A7%E8%83%BD/TCP%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="HTTP" scheme="http://bhsc881114.github.io/tags/HTTP/"/>
    
      <category term="TCP" scheme="http://bhsc881114.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>hadoop系列安装小记</title>
    <link href="http://bhsc881114.github.io/2015/06/18/hadoop%E7%B3%BB%E5%88%97%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/"/>
    <id>http://bhsc881114.github.io/2015/06/18/hadoop系列安装小记/</id>
    <published>2015-06-18T15:41:26.000Z</published>
    <updated>2015-07-09T06:17:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/img-myhadoop-bigger4.jpg" alt="viewport-index"></center><br>最近需要维护hadoop集群，把以前的安装文档翻出来，理了理，记录在此<br><a id="more"></a></p><h1 id="cdh"><a href="#cdh" class="headerlink" title="cdh"></a>cdh</h1><p>当时装的是5.1.0，现在最新的版本是<a href="http://www.cloudera.com/content/cloudera/en/documentation/core/latest/topics/cdh_vd_cdh_package_tarball.html" target="_blank" rel="noopener">5.4.2</a>，因为有在线业务使用，所以暂时不升级。独立下载hadoop各个组件再安装比较繁琐(hdfs+yarn+hbsae+zk+hive)，没有选好版本可能会冲突，CDH的版本都是选定好的，安装和升级文档齐全,非常方便</p><ul><li><a href="http://www.cloudera.com/content/cloudera/en/documentation/core/latest/topics/cdh_vd_cdh_package_previous.html?scroll=topic_7#concept_rjt_wjx_dp_unique_2" target="_blank" rel="noopener">5.1.0各版本信息</a></li><li><a href="http://www.cloudera.com/content/cloudera/en/documentation/cdh5/v5-1-x/CDH5-Installation-Guide/CDH5-Installation-Guide.html" target="_blank" rel="noopener">5.1.0安装文档</a></li><li><a href="http://www.cloudera.com/content/cloudera/en/documentation/core/latest/topics/cdh_ig_upgrade_command_line.html" target="_blank" rel="noopener">升级文档</a></li></ul><h1 id="安装前配置"><a href="#安装前配置" class="headerlink" title="安装前配置"></a>安装前配置</h1><p><strong><a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/CDH5-Installation-Guide/cdh5ig_cdh5_install.html" target="_blank" rel="noopener">官方流程</a></strong> 大致分一下3个步骤：</p><ul><li>1.<a href="http://www.cloudera.com/content/cloudera/en/documentation/core/latest/topics/cdh_ig_cdh5_install.html" target="_blank" rel="noopener">配置cdh库，并通过yum安装</a></li><li>2.<a href="http://www.cloudera.com/content/cloudera/en/documentation/core/latest/topics/cdh_ig_cdh5_cluster_deploy.html#topic_11" target="_blank" rel="noopener">配置网络/hdfs/YARN等</a></li><li>3.<a href="http://www.cloudera.com/content/cloudera/en/documentation/core/latest/topics/cdh_ig_cdh5_comp_install.html#topic_4_5_unique_4" target="_blank" rel="noopener">其他组件安装,比如hbase/hive</a></li></ul><h2 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://archive.cloudera.com/cdh5/one-click-install/redhat/5/x86_64/cloudera-cdh-5-0.x86_64.rpm</span><br><span class="line">sudo yum --nogpgcheck localinstall cloudera-cdh-5-0.x86_64.rpm   #安装rpm，会加一个clouder的yum源：</span><br><span class="line">yum clean all 、 yum makecache # 重新构建yum缓存</span><br><span class="line">sudo rpm --import http://archive.cloudera.com/cdh5/redhat/5/x86_64/cdh/RPM-GPG-KEY-cloudera #导入GPG验证的key</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* 可能的问题:</span><br><span class="line">1.运行yum的可能遇到错误:</span><br><span class="line">It&apos;s possible that the above module doesn&apos;t match the current version of Python, which is:2.7.3 (default, May 19</span><br><span class="line">2014, 15:04:50) [GCC 4.1.2 20080704 (Red Hat 4.1.2-46)]</span><br><span class="line"></span><br><span class="line">需要修改yum的python依赖版本：</span><br><span class="line">修改文件： vim /usr/bin/yum</span><br><span class="line">修改头#!/usr/bin/python  =&gt; #!/usr/bin/python2.4</span><br><span class="line"></span><br><span class="line">2.找不到host命令，需要装下bind-utils：yum install bind-utils</span><br></pre></td></tr></table></figure><h2 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install unzip</span><br><span class="line">curl -L -s get.jenv.io | bash</span><br><span class="line">source /home/admin/.jenv/bin/jenv-init.sh</span><br><span class="line">jenv install java 1.7.0_45</span><br></pre></td></tr></table></figure><p>jdk通过USER账号安装，cdh系列的需要在自己的特定账号下执行，比如hdfs账号，所以会出现找不到JAVA_HOME的问题,解决方法：</p><ul><li>在/etc/sudoers 配置：Defaults env_keep+=JAVA_HOME</li><li>设置ROOT下的JAVA_HOME指向USER。。，需要修改USER为可执行权限</li><li>还有另一个方法，是在/etc/default/bigtop-utils 下配置javahome（chmod 755 /home/USER）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/home/USER/.jenv/candidates/java/current</span><br><span class="line">chmod 755 /home/USER/</span><br></pre></td></tr></table></figure></li></ul><h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p><strong>NameNode、Client</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install hadoop-hdfs-namenode</span><br><span class="line">sudo yum install hadoop-client</span><br></pre></td></tr></table></figure></p><p><strong>安装DataNode</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在DataNode机器上执行：</span><br><span class="line">sudo yum install hadoop-yarn-nodemanager hadoop-hdfs-datanode hadoop-mapreduce</span><br></pre></td></tr></table></figure></p><p><strong>设置hdfs config文件到自己的目录下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -r /etc/hadoop/conf.empty /etc/hadoop/conf.my_cluster</span><br><span class="line">sudo /usr/sbin/alternatives --install /etc/hadoop/conf hadoop-conf /etc/hadoop/conf.my_cluster 50</span><br><span class="line">sudo /usr/sbin/alternatives --set hadoop-conf /etc/hadoop/conf.my_cluster</span><br><span class="line">sudo chmod -R 777 /etc/hadoop/conf.my_cluster</span><br><span class="line">（alternatives --config java好像无效）</span><br><span class="line"></span><br><span class="line">创建数据目录（用户组hdfs:hdfs 权限700）:</span><br><span class="line">datanode：sudo mkdir -p /data/hadoop/hdfs/dn</span><br><span class="line">sudo chown -R hdfs:hdfs /data/hadoop</span><br></pre></td></tr></table></figure><p><strong>hadoop-env.sh</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop默认为namenode、datanode都是1G的内存：</span><br><span class="line">export HADOOP_NAMENODE_OPTS=&quot;$HADOOP_NAMENODE_OPTS -Xmx3072m -verbose:gc -Xloggc:/var/log/hadoop-hdfs/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps&quot;</span><br><span class="line">export HADOOP_DATANODE_OPTS=&quot;$HADOOP_DATANODE_OPTS -Xmx2048m -verbose:gc -Xloggc:/var/log/hadoop-hdfs/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps&quot;</span><br></pre></td></tr></table></figure></p><p><strong>core-site.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">&lt;!-- namenode地址和端口 --&gt;</span><br><span class="line"> &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line"> &lt;value&gt;hdfs://cdhhadoop1:8020&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 回收站，默认保留一天 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line"> &lt;name&gt;fs.trash.interval&lt;/name&gt;</span><br><span class="line"> &lt;value&gt;1440&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line"> &lt;name&gt;fs.trash.checkpoint.interval&lt;/name&gt;</span><br><span class="line"> &lt;value&gt;0&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 配置Snappy压缩 --&gt;</span><br><span class="line"> &lt;property&gt;</span><br><span class="line">  &lt;name&gt;io.compression.codecs&lt;/name&gt;</span><br><span class="line"> &lt;value&gt;org.apache.hadoop.io.compress.DefaultCodec,org.apache.hadoop.io.compress.GzipCodec,org.apache.hadoop.io.compress.BZip2Codec,org.apache.hadoop.io.compress.SnappyCodec&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p><p><strong>配置hdfs-site.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 超级用户 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">   &lt;name&gt;dfs.permissions.superusergroup&lt;/name&gt;</span><br><span class="line">   &lt;value&gt;admin&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- hdfs副本 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">   &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">   &lt;value&gt;2&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- dfs.namenode.name.dir 作为namenode存放元信息的目录，如果设置多个则会有一个拷贝，可以在另外一台机器上搭一个NFS共享目录，作为备份 -&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/data/hadoop/hdfs/nn&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">     &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;/data/hadoop/hdfs/dn&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br></pre></td></tr></table></figure></p><ul><li>其他配置:<blockquote><p>1.如果datanode的目录有一个写失败，DataNode就会停止，这样这个DataNode上的所有目录的副本都会增加，如果要避免这种情况，可以设置容忍失败的目录个数<br>2.可以配置负载均衡，默认的分配策略是随机的，可以配置一个策略比如磁盘大小<br>3.没有配置web hdfs</p></blockquote></li></ul><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul><li><p>格式化namenode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -u hdfs hdfs namenode -format</span><br><span class="line"></span><br><span class="line">日志文件目录：/var/log/hadoop-hdfs</span><br></pre></td></tr></table></figure></li><li><p>启动namenode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service hadoop-hdfs-namenode start</span><br></pre></td></tr></table></figure></li><li><p>启动datanode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service hadoop-hdfs-datanode start</span><br></pre></td></tr></table></figure></li><li><p>初始化</p></li></ul><p>hdfs运行以后，推荐在hdfs上创建tmp目录，并设置权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -u hdfs hadoop fs -mkdir /tmp</span><br><span class="line">$ sudo -u hdfs hadoop fs -chmod -R 1777 /tmp</span><br></pre></td></tr></table></figure></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><a href="http://localhost:50070/dfshealth.html#tab-overview" target="_blank" rel="noopener">http://localhost:50070/dfshealth.html#tab-overview</a></p><p>简单的测试只要执行下hadoop fs命令即可，如果要测试读写性能，要等mapreduce装好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【写性能测试】</span><br><span class="line">hadoop jar /usr/lib/hadoop-0.20-mapreduce/hadoop-test.jar  TestDFSIO -write -nrFiles 10 -fileSize 1000</span><br><span class="line">我们集群的一次测试结果：</span><br><span class="line">----- TestDFSIO ----- : write</span><br><span class="line">           Date &amp; time: Sun Jul 13 21:40:41 CST 2014</span><br><span class="line">       Number of files: 10</span><br><span class="line">Total MBytes processed: 10000.0（总共10个文件，每个1G）</span><br><span class="line">     Throughput mb/sec: 6.452312250618132（总大小/Map总时间）</span><br><span class="line">Average IO rate mb/sec: 6.50354528427124</span><br><span class="line"> IO rate std deviation: 0.6099282285067701</span><br><span class="line">Test exec time sec: 197.818（整体执行时间）</span><br></pre></td></tr></table></figure></p><blockquote><p>Throughput是总大小文/每个Map时间之和，如果算并发吞吐量的话，可以乘以Map数量，详细解读可以参考：<a href="http://www.michael-noll.com/blog/2011/04/09/benchmarking-and-stress-testing-an-hadoop-cluster-with-terasort-testdfsio-nnbench-mrbench/" target="_blank" rel="noopener">Benchmarking and Stress Testing an Hadoop Cluster With TeraSort, TestDFSIO &amp; Co</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">【读性能测试】</span><br><span class="line">hadoop jar /usr/lib/hadoop-0.20-mapreduce/hadoop-test.jar  TestDFSIO -read -nrFiles 10 -fileSize 1000</span><br><span class="line">20:38:21 INFO fs.TestDFSIO: ----- TestDFSIO ----- : read</span><br><span class="line">20:38:21 INFO fs.TestDFSIO:  Date &amp; time: Tue Jul 15 20:38:21 CST 2014</span><br><span class="line">20:38:21 INFO fs.TestDFSIO:        Number of files: 10</span><br><span class="line">20:38:21 INFO fs.TestDFSIO: Total MBytes processed: 10000.0</span><br><span class="line">20:38:21 INFO fs.TestDFSIO:      Throughput mb/sec: 16.79261125104954</span><br><span class="line">20:38:21 INFO fs.TestDFSIO: Average IO rate mb/sec: 16.829221725463867</span><br><span class="line">20:38:21 INFO fs.TestDFSIO:  IO rate std deviation: 0.8154139285912413</span><br><span class="line">20:38:21 INFO fs.TestDFSIO:     Test exec time sec: 84.614</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试结果以后需要清理测试结果</span><br><span class="line">hadoop jar /usr/lib/hadoop-0.20-mapreduce/hadoop-test.jar  TestDFSIO -clean</span><br></pre></td></tr></table></figure><p>&gt;<br>在windows看客户端下测试Hdfs，需要到<br><a href="https://github.com/srccodes/hadoop-common-2.2.0-bin" target="_blank" rel="noopener">https://github.com/srccodes/hadoop-common-2.2.0-bin</a> 下载并替换hadoopHome下的bin目录</p><h1 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h1><h2 id="安装和配置-1"><a href="#安装和配置-1" class="headerlink" title="安装和配置"></a>安装和配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install hadoop-yarn-resourcemanager</span><br><span class="line">sudo yum install hadoop-mapreduce-historyserver hadoop-yarn-proxyserver</span><br><span class="line">sudo mkdir -p /data/yarn/local</span><br><span class="line">sudo mkdir -p /data/yarn/logs</span><br><span class="line">sudo chown -R yarn:yarn /data/yarn</span><br><span class="line">hadoop fs -mkdir -p /user/history</span><br><span class="line">hadoop fs -chmod -R 1777 /user/history</span><br><span class="line">hadoop fs -chown mapred:hadoop /user/history</span><br></pre></td></tr></table></figure><p><strong>yarn-site.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;cdhhadoop1&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;cdhhadoop1:8088&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services.mapreduce_shuffle.class&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;description&gt;List of directories to store localized files in.&lt;/description&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.local-dirs&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;file:///data/yarn/local&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;description&gt;Where to store container logs.&lt;/description&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.log-dirs&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;file:///data/yarn/logs&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;description&gt;Where to aggregate logs to.&lt;/description&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.remote-app-log-dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hdfs:///log/yarn/apps&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;description&gt;Classpath for typical applications.&lt;/description&gt;</span><br><span class="line">     &lt;name&gt;yarn.application.classpath&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;</span><br><span class="line">        $HADOOP_CONF_DIR,</span><br><span class="line">        $HADOOP_COMMON_HOME/*,$HADOOP_COMMON_HOME/lib/*,</span><br><span class="line">        $HADOOP_HDFS_HOME/*,$HADOOP_HDFS_HOME/lib/*,</span><br><span class="line">        $HADOOP_MAPRED_HOME/*,$HADOOP_MAPRED_HOME/lib/*,</span><br><span class="line">        $HADOOP_YARN_HOME/*,$HADOOP_YARN_HOME/lib/*</span><br><span class="line">     &lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br></pre></td></tr></table></figure></p><h2 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h2><ul><li>端口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resourceManager 8088/cluster</span><br><span class="line">nodeManager  8042/node</span><br><span class="line">JobHistory  19888/jobhistory</span><br><span class="line">Name:http://localhost:8088/cluster/nodes</span><br><span class="line">Node1:http://localhost:8042/node</span><br><span class="line">Node2:http://localhost:8043/node</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">通过hadoop自带的randowmwriter测试下：</span><br><span class="line">hadoop jar /usr/lib/hadoop-mapreduce/hadoop-mapreduce-examples.jar randomwriter out</span><br><span class="line">21:14:34 INFO mapreduce.Job: Job job_1405247153654_0004 completed successfully</span><br><span class="line">21:14:34 INFO mapreduce.Job: Counters: 33</span><br><span class="line">        File System Counters</span><br><span class="line">                FILE: Number of bytes read=0</span><br><span class="line">                FILE: Number of bytes written=1772230</span><br><span class="line">                FILE: Number of read operations=0</span><br><span class="line">                FILE: Number of large read operations=0</span><br><span class="line">                FILE: Number of write operations=0</span><br><span class="line">                HDFS: Number of bytes read=2350</span><br><span class="line">                HDFS: Number of bytes written=21545727074（写入20G）</span><br><span class="line">                HDFS: Number of read operations=80</span><br><span class="line">                HDFS: Number of large read operations=0</span><br><span class="line">                HDFS: Number of write operations=40</span><br><span class="line">        Job Counters</span><br><span class="line">                Killed map tasks=10</span><br><span class="line">                Launched map tasks=30</span><br><span class="line">                Other local map tasks=30</span><br><span class="line">                Total time spent by all maps in occupied slots (ms)=7247472</span><br><span class="line">                Total time spent by all reduces in occupied slots (ms)=0</span><br><span class="line">                Total time spent by all map tasks (ms)=7247472</span><br><span class="line">                Total vcore-seconds taken by all map tasks=7247472</span><br><span class="line">                Total megabyte-seconds taken by all map tasks=7421411328</span><br><span class="line">        Map-Reduce Framework</span><br><span class="line">                Map input records=20</span><br><span class="line">                Map output records=2043801</span><br><span class="line">                Input split bytes=2350</span><br><span class="line">                Spilled Records=0</span><br><span class="line">                Failed Shuffles=0</span><br><span class="line">                Merged Map outputs=0</span><br><span class="line">                GC time elapsed (ms)=8157</span><br><span class="line">                CPU time spent (ms)=641440</span><br><span class="line">                Physical memory (bytes) snapshot=2889732096</span><br><span class="line">                Virtual memory (bytes) snapshot=14388494336</span><br><span class="line">                Total committed heap usage (bytes)=2371878912</span><br><span class="line">        org.apache.hadoop.examples.RandomWriter$Counters</span><br><span class="line">                BYTES_WRITTEN=21475013178</span><br><span class="line">                RECORDS_WRITTEN=2043801</span><br><span class="line">        File Input Format Counters</span><br><span class="line">                Bytes Read=0</span><br><span class="line">        File Output Format Counters</span><br><span class="line">                Bytes Written=21545727074</span><br><span class="line">The job took 604 seconds.</span><br></pre></td></tr></table></figure><h1 id="ZK"><a href="#ZK" class="headerlink" title="ZK"></a>ZK</h1><h2 id="安装和配置-2"><a href="#安装和配置-2" class="headerlink" title="安装和配置"></a>安装和配置</h2><p><em>安装</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install zookeeper</span><br><span class="line">sudo yum install zookeeper-server</span><br></pre></td></tr></table></figure></p><p><strong>拷贝配置</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -r /etc/zookeeper/conf.dist /etc/zookeeper/conf.my_cluster</span><br><span class="line">sudo alternatives --verbose --install /etc/zookeeper/conf zookeeper-conf /etc/zookeeper/conf.my_cluster 50</span><br><span class="line">sudo alternatives --set zookeeper-conf /etc/zookeeper/conf.my_cluster</span><br></pre></td></tr></table></figure></p><p><strong>修改配置文件并在节点间同步</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/zookeeper/conf.my_cluster/zoo.cfg</span><br><span class="line">server.1=A:2888:3888</span><br><span class="line">server.2=B:2888:3888</span><br><span class="line">server.3=C:2888:3888</span><br></pre></td></tr></table></figure></p><p><strong>创建数据目录</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/zookeeper</span><br><span class="line">chown -R zookeeper:zookeeper /data/zookeeper</span><br></pre></td></tr></table></figure></p><h2 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">启动日志在/var/log/zookeeper</span><br><span class="line">在A运行 :</span><br><span class="line">$ service zookeeper-server init --myid=1</span><br><span class="line">$ service zookeeper-server start</span><br><span class="line">在B运行</span><br><span class="line">$ service zookeeper-server init --myid=2</span><br><span class="line">$ service zookeeper-server start</span><br><span class="line">在C运行</span><br><span class="line">$ service zookeeper-server init --myid=3</span><br><span class="line">$ service zookeeper-server start</span><br></pre></td></tr></table></figure><h2 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zookeeper-client -server A:2181</span><br><span class="line">zookeeper-client -server B:2181</span><br><span class="line"></span><br><span class="line">目录列表： ls /</span><br><span class="line">创建目录： create /test &quot;empty&quot;</span><br></pre></td></tr></table></figure><h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><h2 id="安装和配置-3"><a href="#安装和配置-3" class="headerlink" title="安装和配置"></a>安装和配置</h2><p><strong>安装</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所有机器上： sudo yum install hbase</span><br><span class="line">NameNode：sudo yum install hbase-master</span><br><span class="line">DataNode： sudo yum install hbase-regionserver</span><br></pre></td></tr></table></figure></p><p><strong>拷贝自己的配置文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -r /etc/hbase/conf.dist /etc/hbase/conf.my_cluster</span><br><span class="line">sudo alternatives --verbose --install /etc/hbase/conf hbase-conf /etc/hbase/conf.my_cluster 50</span><br><span class="line">sudo alternatives --set hbase-conf /etc/hbase/conf.my_cluster</span><br></pre></td></tr></table></figure></p><p><strong>修改最大文件数限制</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">避免Too many open files（/etc/security/limits.conf）</span><br><span class="line">hdfs  -       nofile  32768</span><br><span class="line">hbase -       nofile  32768</span><br><span class="line">阿里云机器默认已经是65535，所以不做修改</span><br><span class="line"></span><br><span class="line">hdfs DataNode会限制打开的文件数（ /etc/hadoop/conf/hdfs-site.xml）</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.datanode.max.xcievers&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;65535&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p><p><strong>创建目录</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir /hbase</span><br><span class="line">hadoop fs -chown hbase /hbase</span><br></pre></td></tr></table></figure></p><p><strong>hbase-site.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hbase.rootdir&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;hdfs://myhost:8020/hbase&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;A,B,C&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!--关闭checksum--&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.regionserver.checksum.verify&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;</span><br><span class="line">        If set to  true, HBase will read data and then verify checksums  for</span><br><span class="line">        hfile blocks. Checksum verification inside HDFS will be switched off.</span><br><span class="line">        If the hbase-checksum verification fails, then it will  switch back to</span><br><span class="line">        using HDFS checksums.</span><br><span class="line">    &lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.hstore.checksum.algorithm&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;NULL&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;</span><br><span class="line">      Name of an algorithm that is used to compute checksums. Possible values</span><br><span class="line">      are NULL, CRC32, CRC32C.</span><br><span class="line">    &lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><h2 id="启动-3"><a href="#启动-3" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service hbase-master start</span><br><span class="line">service hbase-regionserver start</span><br></pre></td></tr></table></figure><h2 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">60010是master的端口 http://localhost:60010/master-status?filter=all</span><br><span class="line">60030是regionServer的端口</span><br><span class="line"></span><br><span class="line">测试hbase集群是否支持snappy：</span><br><span class="line">hbase org.apache.hadoop.hbase.util.CompressionTest hdfs://namenode:8020/benchmarks/hbase snappy</span><br><span class="line">通过hbase shell访问hbase</span><br></pre></td></tr></table></figure><h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><h2 id="安装和配置-4"><a href="#安装和配置-4" class="headerlink" title="安装和配置"></a>安装和配置</h2><p><strong>安装hive/metastore/hieveserver</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y hive</span><br><span class="line">sudo yum install -y hive-metastore</span><br><span class="line">sudo yum install -y hive-server2</span><br></pre></td></tr></table></figure></p><p><strong>mysql-connector-java.jar</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在metastore的机器，把mysql-connector-java.jar放到/usr/lib/hive/lib/目录下</span><br></pre></td></tr></table></figure></p><p><strong>java堆配置</strong><br><a href="http://www.cloudera.com/content/cloudera/en/documentation/core/latest/topics/cdh_ig_hive_install.html#concept_alp_4kl_3q_unique_1" target="_blank" rel="noopener">我们配置的是3G</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">官方文档有误，实际配置文件是:/etc/hive/conf/hive-env.sh</span><br><span class="line">if [ &quot;$SERVICE&quot; = &quot;hiveserver2或者metastore&quot; ]; then</span><br><span class="line">   export HADOOP_OPTS=&quot;$&#123;HADOOP_OPTS&#125; -Xmx3072m -Xms1024m -Xloggc:/var/log/hive/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps&quot;</span><br><span class="line">fi</span><br><span class="line">export HADOOP_HEAPSIZE=512</span><br></pre></td></tr></table></figure></p><p><strong>metastore配置(配置文件：hive-site.xml)</strong><br><a href="http://www.cloudera.com/content/cloudera/en/documentation/cdh5/v5-1-x/CDH5-Installation-Guide/cdh5ig_hive_metastore_configure.html" target="_blank" rel="noopener">参考</a></p><p><strong>metastore 配置hdfs</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先初始化下hdfs得配置,再从namenode把最新的配置拷过来：scp /etc/hadoop/conf.my_cluster/hdfs-site.xml /etc/hadoop/conf.my_cluster/core-site.xml host:/etc/hadoop/conf.my_cluster/</span><br></pre></td></tr></table></figure></p><p><strong>hiveserver2配置(配置文件：/etc/hive/conf/hive-site.xml)</strong><br><a href="http://www.cloudera.com/content/cloudera/en/documentation/cdh5/v5-1-x/CDH5-Installation-Guide/cdh5ig_hiveserver2_configure.html" target="_blank" rel="noopener">主要是配置metastore地址，zk地址</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hive.support.concurrency&lt;/name&gt;</span><br><span class="line">  &lt;description&gt;Enable Hive&apos;s Table Lock Manager Service&lt;/description&gt;</span><br><span class="line">  &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hive.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">  &lt;description&gt;Zookeeper quorum used by Hive&apos;s Table Lock Manager&lt;/description&gt;</span><br><span class="line">  &lt;value&gt;A,B,C&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hive.metastore.local&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hive.metastore.uris&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;thrift://xxxxx:9083&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p><h2 id="启动-4"><a href="#启动-4" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo /sbin/service hive-metastore start</span><br><span class="line">sudo /sbin/service hive-server2 start</span><br></pre></td></tr></table></figure><h2 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h2><ul><li>1./usr/lib/hive/bin/beeline</li><li>2.!connect jdbc:hive2://localhost:10000 username password org.apache.hive.jdbc.HiveDriver<br>  或者： !connect jdbc:hive2://10.241.52.161:10000 username password org.apache.hive.jdbc.HiveDriver</li><li>3.show tables;</li></ul><blockquote><p>hive服务端日志在：/var/log/hive<br>hive shell日志在/tmp/admin/hive.log，之前有个配置错误引起的异常，一直没找到日志，原来路径是在/etc/hive/conf下的log4j配置的</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://hadooper.blogspot.jp/2010/11/platform-base-hdfs-mr.html" target="_blank" rel="noopener">Platform base: HDFS + MR</a></li><li><a href="http://blog.fens.me/hadoop-hive-intro/" target="_blank" rel="noopener">hive搭建&amp;测试</a></li><li><a href="http://www.csdn.net/article/2015-06-08/2824889?utm_source=tuicool" target="_blank" rel="noopener">从Hadoop到Spark的架构实践</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;img src=&quot;http://7xijc0.com1.z0.glb.clouddn.com/img-myhadoop-bigger4.jpg&quot; alt=&quot;viewport-index&quot;&gt;&lt;/center&gt;&lt;br&gt;最近需要维护hadoop集群，把以前的安装文档翻出来，理了理，记录在此&lt;br&gt;
    
    </summary>
    
      <category term="hadoop" scheme="http://bhsc881114.github.io/categories/hadoop/"/>
    
    
      <category term="hadoop安装" scheme="http://bhsc881114.github.io/tags/hadoop%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>图片压缩</title>
    <link href="http://bhsc881114.github.io/2015/06/07/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"/>
    <id>http://bhsc881114.github.io/2015/06/07/图片压缩/</id>
    <published>2015-06-07T14:46:53.000Z</published>
    <updated>2015-06-07T15:45:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>图片占到了网站的大部分流量，图片压缩可以让图片体积更小，加载速度更快<br><a id="more"></a></p><hr><h1 id="1-有损压缩和无损压缩"><a href="#1-有损压缩和无损压缩" class="headerlink" title="1 有损压缩和无损压缩"></a>1 有损压缩和无损压缩</h1><p>有损压缩，删除部分数据，代表的是jpg<br>无损压缩，压缩像素数据,代表是png</p><h1 id="2-图片存储格式"><a href="#2-图片存储格式" class="headerlink" title="2 图片存储格式"></a>2 图片存储格式</h1><h2 id="2-1-格式以及区别"><a href="#2-1-格式以及区别" class="headerlink" title="2.1 格式以及区别"></a>2.1 格式以及区别</h2><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/image-3.png" alt="2">  </center><h2 id="2-2-jpg和png"><a href="#2-2-jpg和png" class="headerlink" title="2.2 jpg和png"></a>2.2 jpg和png</h2><p>JPG在存储图像时会把图像分解成8<em>8像素的栅格，然后对每个栅格的数据进行压缩处理，当我们放大一幅图像的时候，就会发现这些8</em>8像素栅格中很多细节信息被去除，而通过一些特殊算法用附近的颜色进行填充。这也是为什么我们用JPG存储图像有时会产生块状模糊的原因</p><p>PNG是我们最常见的一种采用无损压缩的图片格式。无损压缩在存储图像前会先判断图像上哪些地方是相同的哪些地方是不同的。<strong>它的压缩原理是通过索引图像上相同区域的颜色进行压缩和还原的，这就意味着只有在图像上出现的颜色数量小于我们可以保存的颜色数量时，我们才能真实的记录和还原图像，否则就会丢失一些图像信息</strong>。</p><p>PNG8最多只能索引256种颜色，所以对于颜色较多的图像不能真实还原；PNG24则可以保存1600多万种颜色，基本能够真实还原我们人类肉眼所可以分别的所有颜色；PNG格式最多可以保存48位颜色通道</p><h2 id="2-3-png8和png24"><a href="#2-3-png8和png24" class="headerlink" title="2.3 png8和png24"></a>2.3 png8和png24</h2><p>PNG8和PNG24后面的数字则是代表这种PNG格式最多可以索引和存储的颜色值。”8″代表2的8次方也就是256色，而24则代表2的24次方大概有1600多万色。</p><p>PNG8还支持1位的布尔透明通道，所谓布尔透明指的是要么完全透明要么完全不透明。而PNG24则支持8位（256阶）的alpha通道透明，也就是说可以存储从完全透明到完全不透明一共256个层级的透明度（即所谓的半透明）</p><h1 id="3-webp"><a href="#3-webp" class="headerlink" title="3.webp"></a>3.webp</h1><p>WebP is a new image format that provides lossless and lossy compression for images on the web. WebP lossless images are 26% smaller in size compared to PNGs. WebP lossy images are 25-34% smaller in size compared to JPEG images at equivalent SSIM index. </p><p><a href="http://isux.tencent.com/introduction-of-webp.html" target="_blank" rel="noopener">WebP 探寻之路</a>提供了很多webp压缩的优化建议，可以参考:</p><blockquote><p>WebP 在解码时间与 PNG 有较明显差异（毫秒级别）之外，总体使用体验和 PNG 基本无差异。同时也需要明确，移动设备的发展迅猛，硬件升级快，上一年的表现也许在今年又有了明显的提升。所以，在 App 中使用 WebP 基本没有技术阻碍。</p></blockquote><h1 id="4-理想的压缩"><a href="#4-理想的压缩" class="headerlink" title="4.理想的压缩"></a>4.理想的压缩</h1><p>理想的压缩模式个人认为能做到下面这样会达到比较好的效果：</p><ul><li>1.用户上传的原图压缩</li><li>2.其次通过图片各项属性的判断，程序认为PNG格式的图片更优，于是选择转换一张PNG格式的图片(或者从PNG转成JPEG)</li><li>3.最后为所上传的图片生成一张WebP格式的图片</li></ul><p><strong>目前我们2，3都是没有做，只做了1。步骤2较复杂，和图片的色值、透明度、面积都有关，步骤3 webp的部分由图片提供商做了。目前我们针对所有的图片都做了压缩，没有提供用户选择压缩比(默认使用有损压缩，压缩系数0.5),所幸的是用户也没觉得糊了</strong></p><hr><p>参考：</p><ul><li>1.<a href="http://isux.tencent.com/introduction-of-webp.html" target="_blank" rel="noopener">WebP 探寻之路</a></li><li>2.<a href="http://isux.tencent.com/zhitu.html" target="_blank" rel="noopener">智图—源于QQ空间图片WebP化的思考</a></li><li>3.<a href="https://developers.google.com/speed/webp/" target="_blank" rel="noopener">A new image format for the Web</a></li><li>4.<a href="http://zmx.im/blog?bname=webp" target="_blank" rel="noopener">美团在webp方面的实践（非常好的实践方案）</a></li><li>5.<a href="https://developers.google.com/speed/webp/docs/compression" target="_blank" rel="noopener">Compression Techniques</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图片占到了网站的大部分流量，图片压缩可以让图片体积更小，加载速度更快&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://bhsc881114.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="图像处理" scheme="http://bhsc881114.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图片基础知识</title>
    <link href="http://bhsc881114.github.io/2015/06/07/%E5%9B%BE%E7%89%87%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://bhsc881114.github.io/2015/06/07/图片基础知识/</id>
    <published>2015-06-07T14:30:31.000Z</published>
    <updated>2015-06-23T13:46:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>位图/矢量图；图像像素和显示密度<br><a id="more"></a></p><hr><h1 id="1-位图和矢量图"><a href="#1-位图和矢量图" class="headerlink" title="1.位图和矢量图"></a>1.位图和矢量图</h1><h2 id="1-1-位图（记述性）"><a href="#1-1-位图（记述性）" class="headerlink" title="1.1 位图（记述性）"></a>1.1 位图（记述性）</h2><p>位图的工作是基于方形像素点的,把图像分为若干个点(像素)，从而储存或再现整幅图像。由于像素数量的限制，所以点阵图像的大小是固定的。缩小或放大图像都会造成对图像的破坏，看下的例子：</p>  <center><img src="http://7xijc0.com1.z0.glb.clouddn.com/image-post-1.png" alt="1">  </center><p>A、B、C、D四个像素，要将2x2扩成3x3，那么就要多出5个像素。图中的标号是1、2、3、4、5。<br>如何确定这原先并不存在的像素的颜色呢？是将现有两个像素的颜色值取平均，去作为新像素的颜色。也就是说AB运算后得出1；AC运算后得出2；BD得出4；CD得出5；3则是由1245运算得出的。</p><h2 id="1-2-矢量（描述性）"><a href="#1-2-矢量（描述性）" class="headerlink" title="1.2 矢量（描述性）"></a>1.2 矢量（描述性）</h2><p>矢量图片，由对象组成。<strong>每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</strong>既然每个对象都是一个自成一体的实体，就可以在维持它原有清晰度和弯曲度的同时，多次移动和改变它的属性，而不会影响图例中的其他对象。矢量图像属于描述性，以线段和计算公式作为记录的对象</p><h2 id="1-3-对比"><a href="#1-3-对比" class="headerlink" title="1.3 对比"></a>1.3 对比</h2><p>想象一条直线，如果以点阵方式来记录，就是从左上角第一个点开始，到右下角最后一个点结束，记录所有像素的颜色。 记录这幅图像(200×50像素)就需要1万个信息。即使这条直线本身并没有那么多像素，但点阵方式也是完整的把整幅图的像素记录下来。如果用矢量来记录这条直线，只需要三个信息：直线起点坐标、直线终点坐标、直线的颜色</p><p>从获取图像这个角度来说，矢量不适合记录色彩较为复杂的图像。所谓获取就是拍照、扫描这类，因为色彩太复杂，矢量格式就要为每个色彩的变化去计算坐标。 如果从创作图像的角度来说，矢量格式同样可以具有非常丰富的色彩</p><p>另外显示器是点阵的，包括传统的CTR显示器、液晶显示器、等离子显示器等。 无论你在制作时候采用点阵还是矢量，在显示器上显示出来的话，最终还是以点阵方式展现的。</p><h1 id="2-RGB"><a href="#2-RGB" class="headerlink" title="2.RGB"></a>2.RGB</h1><p>电子设备上显示的数字图像颜色组成是RGB（红黄蓝),这是一种发光色彩。相对应的有CMYK反光色彩，用于印刷（C代表青色，M代表洋红色，Y代表黄色，K代表黑色）；</p><h2 id="2-1-图像大小"><a href="#2-1-图像大小" class="headerlink" title="2.1 图像大小"></a>2.1 图像大小</h2><p>每个像素存储’RGBA‘值：(R) 红色通道、(G) 绿色通道、(B) 蓝色通道和 (A) alpha（透明度）通道。在浏览器内部为每个通道分配 256 个值（色阶），转换为每个通道 8 位 (2 ^ 8 = 256)，每个像素 4 个字节。因此，如果知道图像尺寸，可以很容易计算文件大小：<br> 100 x 100 像素的图片 =  10,000 像素 x 4 个字节 = 40,000B  / 1024 = 39KB</p><p>每个通道256的值，可以为我们提供1677W的颜色（256<em>256</em>256=16,777,216），这超过了一般人眼的分辨力，所以也称为真彩色</p><h1 id="3-图像像素和显示密度"><a href="#3-图像像素和显示密度" class="headerlink" title="3 图像像素和显示密度"></a>3 图像像素和显示密度</h1><h2 id="3-1-总像素"><a href="#3-1-总像素" class="headerlink" title="3.1 总像素"></a>3.1 总像素</h2><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/image-post-2.png" alt="2">  </center><h2 id="3-2-显示密度-DPI-PPI"><a href="#3-2-显示密度-DPI-PPI" class="headerlink" title="3.2 显示密度 DPI/PPI"></a>3.2 显示密度 DPI/PPI</h2><p>dpi是dot per inch，每英寸多少点，ppi是 Pixel per inch，每英寸像素数，针对显示器的设计时，dpi=ppi(下面都用PPI）。图片的总像素/PPI，就是图片在介质上显示的大小。同一张图片,PPI高的肯定会显示的小一点，这里有很多相关的概念，retina、android里的dp单位、android里的HDPI、MDPI、LDPI等。</p><hr><p>参考：</p><ul><li>1.<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/image-optimization" target="_blank" rel="noopener">图片优化</a></li><li>2.<a href="http://blog.163.com/fan_cun_fu/blog/static/455609201141925812990/" target="_blank" rel="noopener">点阵格式图像介绍</a></li><li>3.<a href="http://www.zhihu.com/question/21220154" target="_blank" rel="noopener">DPI、PPI、DP、PX 的详细计算方法及算法来源是什么？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;位图/矢量图；图像像素和显示密度&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://bhsc881114.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="图像处理" scheme="http://bhsc881114.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>响应式站点2-viewport和media-query</title>
    <link href="http://bhsc881114.github.io/2015/05/22/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%AB%99%E7%82%B92-viewport%E5%92%8Cmedia-query/"/>
    <id>http://bhsc881114.github.io/2015/05/22/响应式站点2-viewport和media-query/</id>
    <published>2015-05-22T00:58:34.000Z</published>
    <updated>2015-07-09T05:47:19.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://bhsc881114.github.io/2015/05/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%AB%99%E7%82%B9-%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/">响应式站点1-技术基础</a></li><li>响应式站点2-viewport和media-query</li><li>响应式站点3-skills(预告)</li></ul><p>以前做一个在手机上的网站，一开始显示的内容都偏小，需要双击缩放才能显示。后来发现加上viewport就可以了，瞬间觉得高大上….扒一扒他的原理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure> </p><p><img src="http://7xijc0.com1.z0.glb.clouddn.com/viewport-2.png" alt="viewport-index"><br><a id="more"></a></p><hr><h1 id="3种viewport"><a href="#3种viewport" class="headerlink" title="3种viewport"></a>3种viewport</h1><p>以前PC端的网站一般宽度在1000px以上,这种大尺寸的页面如何在手机上展示?答案就是：缩放，所以早期看到的网站都很小，需要双击放大某一部分区域才能浏览。</p><h2 id="visual-viewport"><a href="#visual-viewport" class="headerlink" title="visual viewport"></a>visual viewport</h2><p>visuall viewport,显示的屏幕窗口,可以把他理解为放大镜,距离可以拉近一点拉远一点,显示的内容可以缩小可以放大,大致就是下面这个样子：<br>  <center><img src="http://7xijc0.com1.z0.glb.clouddn.com/viewport33.png" alt="viewport">  </center></p><p>比如一个1024px宽的页面，要在320px的手机上显示，可以拉远距离(缩放)全局浏览，也可以拉近只看一部分,并且移动visual viewport来查看网页的不同部分</p><h2 id="layout-viewport"><a href="#layout-viewport" class="headerlink" title="layout viewport"></a>layout viewport</h2><p>PC的网页怎么在320px的手机上渲染？这里有个隐藏的概念,就是layout viewport。当我们设置一个width=20%时,他必须知道父级的width是多少,最终必须找到一个设置绝对值的顶层的元素(body)</p><p>早期没有专门为移动端做的页面,所以手机浏览器默认的layout viewport都是接近pc的宽度，这样可以确保PC的网页展示都没问题。<a href="http://www.quirksmode.org/mobile/metaviewport/" target="_blank" rel="noopener">这里</a>里有每个手机浏览器的默认layot viewport，附个图：</p><p><img src="http://7xijc0.com1.z0.glb.clouddn.com/viewport-4.png" alt="layout"></p><h2 id="修改layout-viewport"><a href="#修改layout-viewport" class="headerlink" title="修改layout viewport"></a>修改layout viewport</h2><p>layout viewport+visual viewport，PC端网页已经可以在手机上展示了，不过显然还不够完美：<strong>能不能不要缩放，不要双击放大以后再拖动来看网页?</strong> 假设手机宽度是320px，那就做个宽度只有320px的页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body style=&quot;width:320px&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;contianer&quot;&gt;</span><br><span class="line">      hello everyone</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br> <center><img src="http://7xijc0.com1.z0.glb.clouddn.com/viewport-6.png" alt="pc viewport"> </center><br>可以看到因为默认的layout viewport是按PC设置的，就算设置一个320px，也会按照PC的效果来展示</p><p>ios最早提供了<a href="https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html" target="_blank" rel="noopener">修改layout viewport</a>的能力，我们给上面的页面设置下layout viewport，并且visual viewport不缩放，这样就完美了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=320px, initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure><br>  <center><img src="http://7xijc0.com1.z0.glb.clouddn.com/viewport-7.png" alt="pc viewport"> </center></p><h2 id="ideal-viewport"><a href="#ideal-viewport" class="headerlink" title="ideal viewport"></a>ideal viewport</h2><p>因为移动端的设备太多,宽度不一,所以上面写死的width=320px是非常不好的。还好设备都有一个ideal viewport，也就是最佳的尺寸，把layout viewport设置成idela viewport，并且visual viewport不要缩放就能达到最好的效果（可能有点绕）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure> width和initial-scale 设置其他值的效果，可以在这里查看：<a href="http://andreasbovens.github.io/understanding-viewpor" target="_blank" rel="noopener">understanding-viewport</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>设置layout viewport为设备宽度，并且visual viewport不缩放，这样就能实现最好的效果，为我们的响应式设计提供了基础</p><hr><h1 id="media-query"><a href="#media-query" class="headerlink" title="media query"></a>media query</h1><p>为不同的设备设置了网页的布局总宽度之后，需要进行区分，以便为不同的宽度设置不同的布局，mediaquery提供了这种能力，它有非常多的属性，不过我们最常用的就是width<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@media (max-width: 480px) &#123; </span><br><span class="line">    // 隐藏某些元素</span><br><span class="line">&#125;</span><br><span class="line">@media (max-width: 768px) &#123;  &#125;</span><br><span class="line">@media (min-width: 1200px) &#123;</span><br><span class="line">  // 显示某些元素 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 恰当的断点很重要，根据<a href="http://reports.quickleft.com/css" target="_blank" rel="noopener">2014 css报告</a>,设置最多的是480，768，990，1200，当然可能和bootstrap用的最多有关</p><h2 id="device-width和width"><a href="#device-width和width" class="headerlink" title="device width和width"></a>device width和width</h2><p>另外可以再看看device width和width这两个值，大部分时候他们实现的效果是一样的，但是还是有一些细小的差别:</p><ul><li>device-wdith 指的是设备的宽度，在pc上你改变拖动浏览器窗口的大小并不会改变这个值</li><li>width:指的是浏览器的宽度</li></ul><p>所以使用width会更好，并且在某些android设备上，使用device-width可能会变成device pixel</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>设置不同的布局宽度、不同宽度设置不同的样式是实现响应式站点的基础。实际使用中，还是有很多细节，比如文字、表格布局、retina 下的图片处理等，下篇继续</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://bhsc881114.github.io/2015/05/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%AB%99%E7%82%B9-%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/&quot;&gt;响应式站点1-技术基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;响应式站点2-viewport和media-query&lt;/li&gt;
&lt;li&gt;响应式站点3-skills(预告)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以前做一个在手机上的网站，一开始显示的内容都偏小，需要双击缩放才能显示。后来发现加上viewport就可以了，瞬间觉得高大上….扒一扒他的原理&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xijc0.com1.z0.glb.clouddn.com/viewport-2.png&quot; alt=&quot;viewport-index&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://bhsc881114.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="响应式" scheme="http://bhsc881114.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="viewport" scheme="http://bhsc881114.github.io/tags/viewport/"/>
    
      <category term="media-query" scheme="http://bhsc881114.github.io/tags/media-query/"/>
    
  </entry>
  
  <entry>
    <title>响应式站点1-技术基础</title>
    <link href="http://bhsc881114.github.io/2015/05/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%AB%99%E7%82%B9-%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"/>
    <id>http://bhsc881114.github.io/2015/05/12/响应式站点-技术基础/</id>
    <published>2015-05-11T16:36:10.000Z</published>
    <updated>2015-06-07T15:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>响应式开发背后的技术基础，主要是设备尺寸、设备密度</p><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/responsive-web-design.jpg" alt="viewport-index"></center><a id="more"></a><hr><p>响应式是指网站在不同分辨率、不同大小的设备下，实现比较好的体验，背后的技术基础在于区分不同设备的尺寸、密度</p><h1 id="1-设备尺寸和分辨率"><a href="#1-设备尺寸和分辨率" class="headerlink" title="1.设备尺寸和分辨率"></a>1.设备尺寸和分辨率</h1><p>PC时代，设备尺寸一般控制在1024px，基本不考虑用户主动改变浏览器大小的情况。诺基亚时代，已经可以小尺寸设备访问网站，那时候网路差，上网本来就不方便，整体体验都不好，网页都是按照PC渲染，再局部放大将就着看。</p><p>iphone刚出现时，也是通过先加载全部网页再放大局部浏览，后面出现了为iphone量身定制的网站，直接设置宽度为320px。ios最先引入了meta viewport来允许用户修改视窗的大小，来达到最好的效果。</p><p><strong> 可以在这里直观的感受下：<a href="http://andreasbovens.github.io/understanding-viewport/" target="_blank" rel="noopener">http://andreasbovens.github.io/understanding-viewport/</a> </strong></p>  <center><img src="http://7xijc0.com1.z0.glb.clouddn.com/resp-viewport1.png" alt="img">（不设置viewport）</center>  <center><img src="http://7xijc0.com1.z0.glb.clouddn.com/resp-viewport2.png" alt="img">（设置了width=device-width之后）</center><h1 id="设备密度"><a href="#设备密度" class="headerlink" title="设备密度"></a>设备密度</h1><p>iphone3和4都是3.5寸，前者分辨率是320*480，后者是640何960，这和设备密度有关</p><p><strong> devic pixel：</strong> 物理像素(长宽单位为1)。在屏幕上，元素其实是通过硬件的物理点（RGB）来展示的。1个大设备上的点比小设备上的点要大(很容易理解)，只是因为我们看的距离不同（看电视会坐的比较远，看手机会拿的很近），所以对我们来说看着都比较清晰</p><p><strong> css pixel：</strong> css像素，假设有个div宽20px; 如果以绝对的1:1物理点来显示的话，必然大屏幕的20px会比小屏的px大（想象一下设置一个宽度，在电脑和手机上表现不一样，这就太坑爹了）。 我们实际web开发的时候没遇到这样的问题，因为css px是一个中间层，在retina屏上1X1的css pixel点以4(2X2)个device pixel来展示</p><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/pixratio.png" alt="img"></center><p><strong> devicePixelRatio：</strong> 设备像素比，就是指多少个物理像素来显示一个逻辑像素，现在比较多的是2，3也有,可以同通过window.devicePixelRatio获得</p><p><strong> device width：</strong> 设备宽度，指逻辑像素下的款宽度（就是上面的css pixel），比如iphone的device width就是320*480。这里可以查看各种设备的物理像素和逻辑像素</p><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><p>对文字来说，其实不存在不同密度下显示的的问题，font-size:12px;在不同设备上看着都是一样得，因为可以自动的以多个物理点来显示一个逻辑点。但是图片就没这么容易了，一个200<em>200px的图片在2倍密度的设备上，实际对应的是400</em>400的物理点，多出来的点只能以临近的值来填充，所以就会显得模糊。</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片的响应式确实是一个比较棘手的问题，除了视觉上，还有性能上的问题要考虑，上面200<em>200px像素的问题，简单的做法就是提供一张400</em>400的图片，以200*200展示</p><hr><h1 id="深入viewport"><a href="#深入viewport" class="headerlink" title="深入viewport"></a>深入viewport</h1><p><a href="http://bhsc881114.github.io/2015/05/22/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%AB%99%E7%82%B92-viewport%E5%92%8Cmedia-query/">响应式站点2-viewport和media-query</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;响应式开发背后的技术基础，主要是设备尺寸、设备密度&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://7xijc0.com1.z0.glb.clouddn.com/responsive-web-design.jpg&quot; alt=&quot;viewport-index&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="前端" scheme="http://bhsc881114.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="响应式" scheme="http://bhsc881114.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="viewport" scheme="http://bhsc881114.github.io/tags/viewport/"/>
    
      <category term="devicePixelRatio" scheme="http://bhsc881114.github.io/tags/devicePixelRatio/"/>
    
  </entry>
  
  <entry>
    <title>一次linux内存问题排查-slab</title>
    <link href="http://bhsc881114.github.io/2015/04/19/%E4%B8%80%E6%AC%A1linux%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-slab/"/>
    <id>http://bhsc881114.github.io/2015/04/19/一次linux内存问题排查-slab/</id>
    <published>2015-04-19T00:08:47.000Z</published>
    <updated>2015-07-18T08:48:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>一次内存告警的排查过程，linux内存占用分析<br><a id="more"></a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>有一台机器内存不足的告警，机器内存总共8G，top看了下:<br><img src="http://7xijc0.com1.z0.glb.clouddn.com/A1.png" alt="img"></p><p>已经使用有7G，进程实际占用的物理内存是RES，目测实际应该只占了3G不到，数据对不上，什么鬼</p><h1 id="内存占用分析"><a href="#内存占用分析" class="headerlink" title="内存占用分析"></a>内存占用分析</h1><p>主要参考了<a href="http://blog.yufeng.info/archives/2456" target="_blank" rel="noopener">Linux Used内存到底哪里去了</a>，收获挺大，分享下</p><h2 id="nmon、slabtop等工具"><a href="#nmon、slabtop等工具" class="headerlink" title="nmon、slabtop等工具"></a>nmon、slabtop等工具</h2><p>先装了nmon，他能够比较直观的现实内存占用情况:<br><img src="http://7xijc0.com1.z0.glb.clouddn.com/A2.png" alt="img"><br>通过meminfo也可以看，就是数据有点多，容易忽略<br><img src="http://7xijc0.com1.z0.glb.clouddn.com/A3.png" alt="img"><br>发现slab特别大，应该是这个原因(slabtop)<br><img src="http://7xijc0.com1.z0.glb.clouddn.com/A4.png" alt="img"></p><h2 id="分析slab占用情况"><a href="#分析slab占用情况" class="headerlink" title="分析slab占用情况"></a>分析slab占用情况</h2><p>把slab占用比较大的打出来,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/slabinfo |awk &apos;&#123;if($3*$4/1024/1024 &gt; 100)&#123;print $1,$3*$4/1024/1024&#125; &#125;&apos;</span><br><span class="line"></span><br><span class="line"> ext3_inode_cache 282.575</span><br><span class="line"> proc_inode_cache 2154.03</span><br><span class="line"> dentry_cache 868.075</span><br></pre></td></tr></table></figure></p><p><strong>发现proc_inode这个占了2G多，当然dentry也不小，proc的文件是挺多，但是这么多肯定不正常</strong></p><hr><h1 id="释放缓存"><a href="#释放缓存" class="headerlink" title="释放缓存"></a>释放缓存</h1><p>不知道为啥proc会占这么大，怀疑是阿里云的问题（只是怀疑，最后没查到原因就好了），如果想主动释放inoed可以用下面的方法：</p><p>To free pagecache:</p><ul><li>echo 1 &gt; /proc/sys/vm/drop_caches<br>To free dentries and inodes:</li><li>echo 2 &gt; /proc/sys/vm/drop_caches<br>To free pagecache, dentries and inodes:</li><li>echo 3 &gt; /proc/sys/vm/drop_caches</li></ul><h1 id="内存使用计算"><a href="#内存使用计算" class="headerlink" title="内存使用计算"></a>内存使用计算</h1><p>内存相关的有有进程的内存管理、伙伴分配算法、slab、page table、MNU，page cache等等，每一项都值得展开，这里先只看怎么计算内存使用，霸爷给出的计算方式挺靠谱：slab+page table+res</p><h2 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h2><p>slab 个人解就是一个内存池，因为一个page太大了放一些小对象不经济，所以就搞了个对象池，用于分配这些小对象，可以参考<br><a href="http://stackoverflow.com/questions/15470560/what-to-choose-between-slab-and-slub-allocator-in-linux-kernel" target="_blank" rel="noopener">slab、slub、slob</a>，另外还有slub更适应现代高性能服务器大量进程的情况，代码也更简单</p><h2 id="RES"><a href="#RES" class="headerlink" title="RES"></a>RES</h2><p>RES指进程实际占用的内存（resident resident set size），man top给出的算法是 RES = CODE + DATA.实际中我发现很多进程对不上，whatever</p><h2 id="page-table"><a href="#page-table" class="headerlink" title="page table"></a>page table</h2><p>linux的内存分page来管理（一般是4K），所有有个page table做描述信息也很好理解<br><img src="http://7xijc0.com1.z0.glb.clouddn.com/page-table.png" alt="img"></p><h2 id="buffer、cache"><a href="#buffer、cache" class="headerlink" title="buffer、cache"></a>buffer、cache</h2><p>buffer和cache是已经使用的内存，可以释放。page cache，他和文件系统关系比较大，后续分享rocketmq时再细讲吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一次内存告警的排查过程，linux内存占用分析&lt;br&gt;
    
    </summary>
    
      <category term="linux内存" scheme="http://bhsc881114.github.io/categories/linux%E5%86%85%E5%AD%98/"/>
    
    
      <category term="slab" scheme="http://bhsc881114.github.io/tags/slab/"/>
    
      <category term="内存" scheme="http://bhsc881114.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="pagecache" scheme="http://bhsc881114.github.io/tags/pagecache/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="http://bhsc881114.github.io/2015/03/29/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>http://bhsc881114.github.io/2015/03/29/新的开始/</id>
    <published>2015-03-29T09:56:06.000Z</published>
    <updated>2015-04-28T15:09:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img02.taobaocdn.com/imgextra/i2/86965659/TB2a6n7cXXXXXahXpXXXXXXXXXX-86965659.jpg" alt="i am back"></p><p>大学的时候在iteye、网易、csdn、360DOC、百度空间都写过博客，工作以后基本就断了,去年年底计划重新开始写，今天终于搭起来了，计划每个月写2到3篇，这样一年也有40篇以上了，每篇都尽量保证质量</p><p>这个博客基本都是技术相关，java、nodejs、前端、大数据等。花了半天时间了解jekyll、octopress、hexo等，最终选择hexo而不是jekyll，主要是考虑想在nodejs方面深入一点，计划搞个自己的模板，再加上有很多前端的小工具想试试，让我更需要搭建这个博客来做试验 :)。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://img02.taobaocdn.com/imgextra/i2/86965659/TB2a6n7cXXXXXahXpXXXXXXXXXX-86965659.jpg&quot; alt=&quot;i am back&quot;&gt;&lt;/p&gt;
&lt;p&gt;大学的时候在iteye、网
      
    
    </summary>
    
      <category term="我" scheme="http://bhsc881114.github.io/categories/%E6%88%91/"/>
    
    
      <category term="我" scheme="http://bhsc881114.github.io/tags/%E6%88%91/"/>
    
  </entry>
  
</feed>
